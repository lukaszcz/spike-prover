Resetting all values
Opening ../examples/even_odd.spike

Successfully parsed sorts

Successfully parsed constructors

Successfully parsed functions

Successfully parsed axioms
All constructors are free
dico_const_string:
2 --> 0
-1 --> evenm
5 --> false
-6 --> oddc
-2 --> oddm
-4 --> odd
-5 --> evenr
-3 --> even
3 --> S
-7 --> plus
4 --> true

Successfully parsed equivalence relation

Successfully parsed statuses
dico_id_status:
Completing status dico with default status "Multiset"
AC symbols: 
Case 0: no AC symbols
Orienting axioms
	[ 17 ] plus (0, u1) -> u1 ;
	[ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;
	[ 19 ] evenr (0) -> true ;
	[ 20 ] evenr (1) -> false ;
	[ 21 ] evenr (S (S (u1))) -> evenr (u1) ;
	[ 22 ] evenr (u1) = true => oddc (u1) -> false ;
	[ 23 ] evenr (u1) = false => oddc (u1) -> true ;
	[ 24 ] evenm (0) -> true ;
	[ 25 ] evenm (S (u1)) -> oddm (u1) ;
	[ 26 ] oddm (0) -> false ;
	[ 27 ] oddm (S (u1)) -> evenm (u1) ;
	[ 28 ] even (0) -> true ;
	[ 29 ] odd (u1) = true => even (S (u1)) -> true ;
	[ 30 ] odd (u1) = false => even (S (u1)) -> false ;
	[ 31 ] odd (0) -> false ;
	[ 32 ] even (u1) = true => odd (S (u1)) -> true ;
	[ 33 ] even (u1) = false => odd (S (u1)) -> false ;
dico_order:
evenm: plus 0 S true false;
oddc: plus evenr 0 S true false;
oddm: plus 0 S true false;
odd: plus 0 S true false;
evenr: plus 0 S true false;
even: plus 0 S true false;
plus: 0 S;
dico_equivalence:
oddm ~ evenm
odd ~ even
Computing nullary sorts
Sort "bool" is nullary
Sort "nat" is not nullary
Computing nullary individuals
We do not have a boolean specification

Successfully parsed properties
Computing default priorities
Using default priorities
Generate will be attempted on the following positions:
Ind_pos_position ()

Successfully parsed strategies

Successfully parsed startpoint

Successfully parsed conjectures
	[ 34 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

Successfully parsed conjectures
	[ 35 ] evenm (u1) = evenr (u1) ;

Successfully parsed conjectures
	[ 36 ] plus (u1, 0) = u1 ;

Successfully parsed conjectures
	[ 37 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;

Successfully parsed conjectures
	[ 38 ] even (plus (u1, u1)) = true ;
	[ 39 ] odd (S (plus (u1, u1))) = true ;

Successfully parsed conjectures
	[ 40 ] plus (u1, u2) = plus (u2, u1) ;

Successfully parsed conjectures
	[ 41 ] evenm (plus (u1, u1)) = true ;
	[ 42 ] oddm (plus (u1, u1)) = false ;

Successfully parsed conjectures
	[ 43 ] evenr (S (u1)) = true => true = oddm (u1) ;

Successfully parsed conjectures
	[ 44 ] oddc (u1) = oddm (u1) ;
Closing ../examples/even_odd.spike

Successfully parsed conjectures
	[ 45 ] plus (u1, plus (u2, u3)) = plus (plus (u1, u2), u3) ;


************************************************************
******************* Starting computation *******************
************************************************************


dico_st:
fullind = (repeat (stra, inst_var_rule), print_goals_history)
negative_clash_rule = delete(id,[try (negative_clash)])
subsumption_rule = delete(id,[try (subsumption (L&C))])
normalize = repeat try (delete(id,[negative_clash]), simplify(id,[eliminate_redundant_literal]), simplify(id,[eliminate_trivial_literal]), simplify(id,[positive_clash]), simplify(id,[congruence_closure]), simplify(id,[negative_decomposition]), simplify(id,[auto_simplification]), simplify(id,[rewriting (normalize, L&R, *)]), delete(id,[subsumption (L&C)]), simplify(id,[total_case_rewriting (builtin, R, *)]))
stra = repeat (try (tautology_rule, negative_clash_rule, subsumption_rule, decomposition_rule, rewriting_rule, print_goals_history, total_case_rewriting_add_premise_rule))
inst_var_rule = add_premise(generate,[try (id)])
recursive = try (delete, rewrite, add_premise(id,[generate]))
query = ?
generate_reduce = try (delete(id,[tautology]), rewrite)
rewriting_rule = simplify(id,[try (rewriting (rewrite, L&C&R, *))])
tautology_rule = delete(id,[try (tautology)])
total_case_rewriting_add_premise_rule = add_premise(total_case_rewriting (simplify_strat, R, *),[try (id)])
decompose = saturate (simplify(id,[positive_decomposition]), simplify(id,[negative_decomposition]))
clean = saturate (simplify(id,[eliminate_redundant_literal]), simplify(id,[eliminate_trivial_literal]), simplify(id,[positive_clash]))
simplify = saturate (delete, clean, decompose, simplify(id,[auto_simplification]))
total_case_rewriting_rule = simplify(id,[try (total_case_rewriting (simplify_strat, R, *))])
rewrite = try (simplify(id,[rewriting (normalize, R, *)]), simplify(id,[equational_rewriting (*)]), simplify(id,[partial_case_rewriting (R&L, *)]))
builtin = try (delete, rewrite, add_premise(id,[generate]))
decomposition_rule = simplify(id,[try (negative_decomposition)])
delete = saturate (delete(id,[tautology]), delete(id,[subsumption (R&L)]), delete(id,[negative_clash]))
Start point is now fullind

************************  Proving  *************************
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E1 (1):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;


 The history of [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
GENERATE 1 on
« [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

from the positions:
	true/1/[1] --> evenr (plus (u1, u3))
	false/1/[1] --> evenr (plus (u1, u2))
	false/2/[1] --> evenr (plus (u2, u3))
	true/1/[1-1] --> plus (u1, u3)
	false/1/[1-1] --> plus (u1, u2)
	false/2/[1-1] --> plus (u2, u3)
	
at true/1/[1-1] on 	plus (u1, u3) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u1, S (u4) !>

We obtain :

1) [ 56 ] evenr (plus (0, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


REWRITING 1: simplify by rewriting 
« [ 56 ] evenr (plus (0, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;


- rewriting at the position false/1/[1-1]:

plus (0, u2)
   is simplified by : plus (0, u1) -> u1   (from [ 17 ] of R)
   with substitution: <! u1, u2 !> into
u2


» [ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;


REWRITING 2: simplify by rewriting 
« [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


- rewriting at the position false/1/[1-1]:

plus (S (u4), u2)
   is simplified by : plus (S (u1), u2) -> S (plus (u1, u2))   (from [ 18 ] of R)
   with substitution: <! u1, u4 ; u2, u2 !> into
S (plus (u4, u2))


» [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


Current goals E2 (2):
[ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;
[ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


 The history of [ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

<! u1, 0 !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 56 ] evenr (plus (0, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

 The corresponding instance is 
	[ 76 ] evenr (plus (0, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (0, u3)) = true ;

 The history of [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<! u1, S (u4) !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

 The corresponding instance is 
	[ 78 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (S (u4), u3)) = true ;
Current premises H2 (1):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;


GENERATE 2 on
« [ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

from the positions:
	false/2/[1] --> evenr (plus (u2, u3))
	false/2/[1-1] --> plus (u2, u3)
	
at false/2/[1-1] on 	plus (u2, u3) 	 using the test substitutions:

 1) <! u2, 0 !>
 2) <! u2, S (u4) !>

We obtain :

1) [ 88 ] evenr (0) = true /\ evenr (u3) = true => evenr (u3) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;

TAUTOLOGY: delete
« [ 88 ] evenr (0) = true /\ evenr (u3) = true => evenr (u3) = true ;


Current goals E3 (2):
[ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;
[ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


 The history of [ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;

<! u1, 0 !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 56 ] evenr (plus (0, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

<! u2, S (u4) !> 
 	 on [ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

 The corresponding instance is 
	[ 100 ] evenr (plus (0, S (u4))) = true /\ evenr (plus (S (u4), u3)) = true => evenr (plus (0, u3)) = true ;

 The history of [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<! u1, S (u4) !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

 The corresponding instance is 
	[ 102 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (S (u4), u3)) = true ;
Current premises H3 (2):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;


GENERATE 3 on
« [ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;

from the positions:
	false/2/[1] --> evenr (S (plus (u4, u3)))
	false/2/[1-1-1] --> plus (u4, u3)
	
at false/2/[1-1-1] on 	plus (u4, u3) 	 using the test substitutions:

 1) <! u4, 0 !>
 2) <! u4, S (u5) !>

We obtain :

1) [ 112 ] evenr (1) = true /\ evenr (S (u3)) = true => evenr (u3) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 118 ] evenr (S (S (u5))) = true /\ evenr (S (S (plus (u5, u3)))) = true => evenr (u3) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


REWRITING 3: simplify by rewriting 
« [ 112 ] evenr (1) = true /\ evenr (S (u3)) = true => evenr (u3) = true ;


- rewriting at the position false/1/[1]:

evenr (1)
   is simplified by : evenr (1) -> false   (from [ 20 ] of R)
   with substitution: <!  !> into
false


» [ 127 ] false = true /\ evenr (S (u3)) = true => evenr (u3) = true ;


NEGATIVE CLASH: delete
« [ 127 ] false = true /\ evenr (S (u3)) = true => evenr (u3) = true ;


REWRITING 4: simplify by rewriting 
« [ 118 ] evenr (S (S (u5))) = true /\ evenr (S (S (plus (u5, u3)))) = true => evenr (u3) = true ;


- rewriting at the position false/2/[1]:

evenr (S (S (plus (u5, u3))))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, plus (u5, u3) !> into
evenr (plus (u5, u3))


» [ 130 ] evenr (S (S (u5))) = true /\ evenr (plus (u5, u3)) = true => evenr (u3) = true ;


REWRITING 5: simplify by rewriting 
« [ 130 ] evenr (S (S (u5))) = true /\ evenr (plus (u5, u3)) = true => evenr (u3) = true ;


- rewriting at the position false/1/[1]:

evenr (S (S (u5)))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, u5 !> into
evenr (u5)


» [ 138 ] evenr (u5) = true /\ evenr (plus (u5, u3)) = true => evenr (u3) = true ;


SUBSUMPTION: delete
« [ 138 ] evenr (u5) = true /\ evenr (plus (u5, u3)) = true => evenr (u3) = true ;

Subsumed in C1 by [ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;

	with epsilon = <! u2, u5 ; u3, u3 !>

The IH ([ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ; <! u2, u5 ; u3, u3 !>) is checked by the 1-cycle

	([ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ; <! u2, S (u4) !>)
	([ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ; <! u4, S (u5) !>)
	([ 118 ] evenr (S (S (u5))) = true /\ evenr (S (S (plus (u5, u3)))) = true => evenr (u3) = true ; <!  !>)
	([ 130 ] evenr (S (S (u5))) = true /\ evenr (plus (u5, u3)) = true => evenr (u3) = true ; <!  !>)


Current goals E4 (1):
[ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


 The history of [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<! u1, S (u4) !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

 The corresponding instance is 
	[ 150 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (S (u4), u3)) = true ;
Current premises H4 (3):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;
[ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;


GENERATE 4 on
« [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

from the positions:
	true/1/[1] --> evenr (S (plus (u4, u3)))
	false/1/[1] --> evenr (S (plus (u4, u2)))
	false/2/[1] --> evenr (plus (u2, u3))
	true/1/[1-1-1] --> plus (u4, u3)
	false/1/[1-1-1] --> plus (u4, u2)
	false/2/[1-1] --> plus (u2, u3)
	
at true/1/[1-1-1] on 	plus (u4, u3) 	 using the test substitutions:

 1) <! u4, 0 !>
 2) <! u4, S (u5) !>

We obtain :

1) [ 160 ] evenr (S (plus (0, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 166 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (S (plus (u5, u3)))) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


REWRITING 6: simplify by rewriting 
« [ 160 ] evenr (S (plus (0, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;


- rewriting at the position false/1/[1-1-1]:

plus (0, u2)
   is simplified by : plus (0, u1) -> u1   (from [ 17 ] of R)
   with substitution: <! u1, u2 !> into
u2


» [ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;


REWRITING 7: simplify by rewriting 
« [ 166 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (S (plus (u5, u3)))) = true ;


- rewriting at the position true/1/[1]:

evenr (S (S (plus (u5, u3))))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, plus (u5, u3) !> into
evenr (plus (u5, u3))


» [ 186 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;


REWRITING 8: simplify by rewriting 
« [ 186 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;


- rewriting at the position false/1/[1-1-1]:

plus (S (u5), u2)
   is simplified by : plus (S (u1), u2) -> S (plus (u1, u2))   (from [ 18 ] of R)
   with substitution: <! u1, u5 ; u2, u2 !> into
S (plus (u5, u2))


» [ 195 ] evenr (S (S (plus (u5, u2)))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;


REWRITING 9: simplify by rewriting 
« [ 195 ] evenr (S (S (plus (u5, u2)))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;


- rewriting at the position false/1/[1]:

evenr (S (S (plus (u5, u2))))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, plus (u5, u2) !> into
evenr (plus (u5, u2))


» [ 204 ] evenr (plus (u5, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;


SUBSUMPTION: delete
« [ 204 ] evenr (plus (u5, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ;

Subsumed in C1 by [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

	with epsilon = <! u1, u5 ; u2, u2 ; u3, u3 !>

The IH ([ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ; <! u1, u5 ; u2, u2 ; u3, u3 !>) is checked by the 1-cycle

	([ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ; <! u1, S (u4) !>)
	([ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ; <!  !>)
	([ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ; <! u4, S (u5) !>)
	([ 166 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (S (plus (u5, u3)))) = true ; <!  !>)
	([ 186 ] evenr (S (plus (S (u5), u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ; <!  !>)
	([ 195 ] evenr (S (S (plus (u5, u2)))) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u5, u3)) = true ; <!  !>)


Current goals E5 (1):
[ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;


 The history of [ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

<! u1, S (u4) !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<! u4, 0 !> 
 	 on [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<!  !> 
 	 on [ 160 ] evenr (S (plus (0, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

 The corresponding instance is 
	[ 217 ] evenr (plus (1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (1, u3)) = true ;
Current premises H5 (4):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;
[ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;
[ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;


GENERATE 5 on
« [ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

from the positions:
	false/2/[1] --> evenr (plus (u2, u3))
	false/2/[1-1] --> plus (u2, u3)
	
at false/2/[1-1] on 	plus (u2, u3) 	 using the test substitutions:

 1) <! u2, 0 !>
 2) <! u2, S (u5) !>

We obtain :

1) [ 227 ] evenr (1) = true /\ evenr (u3) = true => evenr (S (u3)) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 233 ] evenr (S (S (u5))) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


REWRITING 10: simplify by rewriting 
« [ 227 ] evenr (1) = true /\ evenr (u3) = true => evenr (S (u3)) = true ;


- rewriting at the position false/1/[1]:

evenr (1)
   is simplified by : evenr (1) -> false   (from [ 20 ] of R)
   with substitution: <!  !> into
false


» [ 244 ] false = true /\ evenr (u3) = true => evenr (S (u3)) = true ;


NEGATIVE CLASH: delete
« [ 244 ] false = true /\ evenr (u3) = true => evenr (S (u3)) = true ;


REWRITING 11: simplify by rewriting 
« [ 233 ] evenr (S (S (u5))) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;


- rewriting at the position false/1/[1]:

evenr (S (S (u5)))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, u5 !> into
evenr (u5)


» [ 247 ] evenr (u5) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;


Current goals E6 (1):
[ 247 ] evenr (u5) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;


 The history of [ 247 ] evenr (u5) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;

<! u1, S (u4) !> 
 	 on [ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;

<!  !> 
 	 on [ 62 ] evenr (plus (S (u4), u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<! u4, 0 !> 
 	 on [ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;

<!  !> 
 	 on [ 160 ] evenr (S (plus (0, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

<! u2, S (u5) !> 
 	 on [ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

<!  !> 
 	 on [ 233 ] evenr (S (S (u5))) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;

 The corresponding instance is 
	[ 260 ] evenr (plus (1, S (u5))) = true /\ evenr (plus (S (u5), u3)) = true => evenr (plus (1, u3)) = true ;
Current premises H6 (5):
[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 69 ] evenr (u2) = true /\ evenr (plus (u2, u3)) = true => evenr (u3) = true ;
[ 94 ] evenr (S (u4)) = true /\ evenr (S (plus (u4, u3))) = true => evenr (u3) = true ;
[ 72 ] evenr (S (plus (u4, u2))) = true /\ evenr (plus (u2, u3)) = true => evenr (S (plus (u4, u3))) = true ;
[ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;


GENERATE 6 on
« [ 247 ] evenr (u5) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ;

from the positions:
	false/2/[1] --> evenr (S (plus (u5, u3)))
	false/2/[1-1-1] --> plus (u5, u3)
	
at false/2/[1-1-1] on 	plus (u5, u3) 	 using the test substitutions:

 1) <! u5, 0 !>
 2) <! u5, S (u6) !>

We obtain :

1) [ 270 ] evenr (0) = true /\ evenr (S (u3)) = true => evenr (S (u3)) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 276 ] evenr (S (u6)) = true /\ evenr (S (S (plus (u6, u3)))) = true => evenr (S (u3)) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;

TAUTOLOGY: delete
« [ 270 ] evenr (0) = true /\ evenr (S (u3)) = true => evenr (S (u3)) = true ;


REWRITING 12: simplify by rewriting 
« [ 276 ] evenr (S (u6)) = true /\ evenr (S (S (plus (u6, u3)))) = true => evenr (S (u3)) = true ;


- rewriting at the position false/2/[1]:

evenr (S (S (plus (u6, u3))))
   is simplified by : evenr (S (S (u1))) -> evenr (u1)   (from [ 21 ] of R)
   with substitution: <! u1, plus (u6, u3) !> into
evenr (plus (u6, u3))


» [ 288 ] evenr (S (u6)) = true /\ evenr (plus (u6, u3)) = true => evenr (S (u3)) = true ;


SUBSUMPTION: delete
« [ 288 ] evenr (S (u6)) = true /\ evenr (plus (u6, u3)) = true => evenr (S (u3)) = true ;

Subsumed in C1 by [ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ;

	with epsilon = <! u2, u6 ; u3, u3 !>

The IH ([ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ; <! u2, u6 ; u3, u3 !>) is checked by the 1-cycle

	([ 181 ] evenr (S (u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (S (u3)) = true ; <! u2, S (u5) !>)
	([ 233 ] evenr (S (S (u5))) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ; <!  !>)
	([ 247 ] evenr (u5) = true /\ evenr (S (plus (u5, u3))) = true => evenr (S (u3)) = true ; <! u5, S (u6) !>)
	([ 276 ] evenr (S (u6)) = true /\ evenr (S (S (plus (u6, u3)))) = true => evenr (S (u3)) = true ; <!  !>)



The following initial conjectures are inductive consequences of R

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
Elapsed time: 0.054809 s

--- Global statistics of the main successful operations ---

- tautology               : 2 of 44 tries.
- rewriting               : 12 of 24 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 0 of 36 tries.
- total_case_rewriting    : 0 of 8 tries.
- generate                : 6 of 6 tries.

-----------
  Total clauses: 303

-----------
  Total lemmas: 0

  Max depth    : 1

************************  Proving  *************************
[ 304 ] evenm (u1) = evenr (u1) ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E7 (1):
[ 304 ] evenm (u1) = evenr (u1) ;


 The history of [ 304 ] evenm (u1) = evenr (u1) ;
GENERATE 7 on
« [ 304 ] evenm (u1) = evenr (u1) ;

from the positions:
	true/1/[2] --> evenr (u1)
	true/1/[1] --> evenm (u1)
	
at true/1/[2] on 	evenr (u1) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u1, 1 !>
 3) <! u1, S (S (u2)) !>

We obtain :

1) [ 317 ] evenm (0) = true ;

using the rule [ 19 ] evenr (0) -> true ;
2) [ 323 ] evenm (1) = false ;

using the rule [ 20 ] evenr (1) -> false ;
3) [ 329 ] evenm (S (S (u2))) = evenr (u2) ;

using the rule [ 21 ] evenr (S (S (u1))) -> evenr (u1) ;


REWRITING 13: simplify by rewriting 
« [ 317 ] evenm (0) = true ;


- rewriting at the position true/1/[1]:

evenm (0)
   is simplified by : evenm (0) -> true   (from [ 24 ] of R)
   with substitution: <!  !> into
true


» [ 343 ] true = true ;

TAUTOLOGY: delete
« [ 343 ] true = true ;


REWRITING 14: simplify by rewriting 
« [ 323 ] evenm (1) = false ;


- rewriting at the position true/1/[1]:

evenm (1)
   is simplified by : evenm (S (u1)) -> oddm (u1)   (from [ 25 ] of R)
   with substitution: <! u1, 0 !> into
oddm (0)


» [ 346 ] oddm (0) = false ;


REWRITING 15: simplify by rewriting 
« [ 329 ] evenm (S (S (u2))) = evenr (u2) ;


- rewriting at the position true/1/[1]:

evenm (S (S (u2)))
   is simplified by : evenm (S (u1)) -> oddm (u1)   (from [ 25 ] of R)
   with substitution: <! u1, S (u2) !> into
oddm (S (u2))


» [ 353 ] oddm (S (u2)) = evenr (u2) ;


REWRITING 16: simplify by rewriting 
« [ 346 ] oddm (0) = false ;


- rewriting at the position true/1/[1]:

oddm (0)
   is simplified by : oddm (0) -> false   (from [ 26 ] of R)
   with substitution: <!  !> into
false


» [ 359 ] false = false ;

TAUTOLOGY: delete
« [ 359 ] false = false ;


REWRITING 17: simplify by rewriting 
« [ 353 ] oddm (S (u2)) = evenr (u2) ;


- rewriting at the position true/1/[1]:

oddm (S (u2))
   is simplified by : oddm (S (u1)) -> evenm (u1)   (from [ 27 ] of R)
   with substitution: <! u1, u2 !> into
evenm (u2)


» [ 362 ] evenm (u2) = evenr (u2) ;


SUBSUMPTION: delete
« [ 362 ] evenm (u2) = evenr (u2) ;

Subsumed in C1 by [ 304 ] evenm (u1) = evenr (u1) ;

	with epsilon = <! u1, u2 !>

The IH ([ 304 ] evenm (u1) = evenr (u1) ; <! u1, u2 !>) is checked by the 1-cycle

	([ 304 ] evenm (u1) = evenr (u1) ; <! u1, S (S (u2)) !>)
	([ 329 ] evenm (S (S (u2))) = evenr (u2) ; <!  !>)
	([ 353 ] oddm (S (u2)) = evenr (u2) ; <!  !>)



The following initial conjectures are inductive consequences of R

[ 304 ] evenm (u1) = evenr (u1) ;
Elapsed time: 0.05948 s

--- Global statistics of the main successful operations ---

- tautology               : 4 of 61 tries.
- rewriting               : 17 of 30 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 0 of 48 tries.
- total_case_rewriting    : 0 of 9 tries.
- generate                : 7 of 7 tries.

-----------
  Total clauses: 369

-----------
  Total lemmas: 1

  Max depth    : 1

************************  Proving  *************************
[ 370 ] plus (u1, 0) = u1 ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 304 ] evenm (u1) = evenr (u1) ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E8 (1):
[ 370 ] plus (u1, 0) = u1 ;


 The history of [ 370 ] plus (u1, 0) = u1 ;
GENERATE 8 on
« [ 370 ] plus (u1, 0) = u1 ;

from the positions:
	true/1/[1] --> plus (u1, 0)
	
at true/1/[1] on 	plus (u1, 0) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u1, S (u2) !>

We obtain :

1) [ 382 ] 0 = 0 ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 388 ] S (plus (u2, 0)) = S (u2) ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;

TAUTOLOGY: delete
« [ 382 ] 0 = 0 ;

POSITIVE DECOMPOSITION : simplify
« [ 388 ] S (plus (u2, 0)) = S (u2) ;

» [ 392 ] plus (u2, 0) = u2 ;


SUBSUMPTION: delete
« [ 392 ] plus (u2, 0) = u2 ;

Subsumed in C1 by [ 370 ] plus (u1, 0) = u1 ;

	with epsilon = <! u1, u2 !>

The IH ([ 370 ] plus (u1, 0) = u1 ; <! u1, u2 !>) is checked by the 1-cycle

	([ 370 ] plus (u1, 0) = u1 ; <! u1, S (u2) !>)
	([ 388 ] S (plus (u2, 0)) = S (u2) ; <!  !>)



The following initial conjectures are inductive consequences of R

[ 370 ] plus (u1, 0) = u1 ;
Elapsed time: 0.061043 s

--- Global statistics of the main successful operations ---

- tautology               : 5 of 65 tries.
- rewriting               : 17 of 31 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 0 of 51 tries.
- total_case_rewriting    : 0 of 10 tries.
- generate                : 8 of 8 tries.

-----------
  Total clauses: 399

-----------
  Total lemmas: 2

  Max depth    : 1

************************  Proving  *************************
[ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 304 ] evenm (u1) = evenr (u1) ;
[ 370 ] plus (u1, 0) -> u1 ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E9 (1):
[ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;


 The history of [ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;
GENERATE 9 on
« [ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;

from the positions:
	true/1/[1] --> plus (u1, S (u2))
	
at true/1/[1] on 	plus (u1, S (u2)) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u1, S (u3) !>

We obtain :

1) [ 413 ] S (u2) = S (plus (0, u2)) ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 419 ] S (plus (u3, S (u2))) = S (plus (S (u3), u2)) ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;

POSITIVE DECOMPOSITION : simplify
« [ 413 ] S (u2) = S (plus (0, u2)) ;

» [ 430 ] u2 = plus (0, u2) ;

POSITIVE DECOMPOSITION : simplify
« [ 419 ] S (plus (u3, S (u2))) = S (plus (S (u3), u2)) ;

» [ 436 ] plus (u3, S (u2)) = plus (S (u3), u2) ;


REWRITING 18: simplify by rewriting 
« [ 430 ] u2 = plus (0, u2) ;


- rewriting at the position true/1/[2]:

plus (0, u2)
   is simplified by : plus (0, u1) -> u1   (from [ 17 ] of R)
   with substitution: <! u1, u2 !> into
u2


» [ 444 ] u2 = u2 ;

TAUTOLOGY: delete
« [ 444 ] u2 = u2 ;


REWRITING 19: simplify by rewriting 
« [ 436 ] plus (u3, S (u2)) = plus (S (u3), u2) ;

- rewriting at the position true/1/[1]:

plus (u3, S (u2))
   is simplified by : plus (u1, S (u2)) -> S (plus (u1, u2))   (from [ 400 ] of C1)
   with substitution: <! u1, u3 ; u2, u2 !> into
S (plus (u3, u2))

» [ 448 ] S (plus (u3, u2)) = plus (S (u3), u2) ;



The IH ([ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ; <! u1, u3 ; u2, u2 !>) is checked by the 1-cycle

	([ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ; <! u1, S (u3) !>)
	([ 419 ] S (plus (u3, S (u2))) = S (plus (S (u3), u2)) ; <!  !>)


REWRITING 20: simplify by rewriting 
« [ 448 ] S (plus (u3, u2)) = plus (S (u3), u2) ;


- rewriting at the position true/1/[2]:

plus (S (u3), u2)
   is simplified by : plus (S (u1), u2) -> S (plus (u1, u2))   (from [ 18 ] of R)
   with substitution: <! u1, u3 ; u2, u2 !> into
S (plus (u3, u2))


» [ 458 ] S (plus (u3, u2)) = S (plus (u3, u2)) ;

TAUTOLOGY: delete
« [ 458 ] S (plus (u3, u2)) = S (plus (u3, u2)) ;



The following initial conjectures are inductive consequences of R

[ 400 ] plus (u1, S (u2)) = S (plus (u1, u2)) ;
Elapsed time: 0.064554 s

--- Global statistics of the main successful operations ---

- tautology               : 7 of 77 tries.
- rewriting               : 20 of 35 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 0 of 60 tries.
- total_case_rewriting    : 0 of 11 tries.
- generate                : 9 of 9 tries.

-----------
  Total clauses: 458

-----------
  Total lemmas: 3

  Max depth    : 1

************************  Proving  *************************
[ 459 ] even (plus (u1, u1)) = true ;
[ 460 ] odd (S (plus (u1, u1))) = true ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 304 ] evenm (u1) = evenr (u1) ;
[ 370 ] plus (u1, 0) -> u1 ;
[ 400 ] plus (u1, S (u2)) -> S (plus (u1, u2)) ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E10 (2):
[ 459 ] even (plus (u1, u1)) = true ;
[ 460 ] odd (S (plus (u1, u1))) = true ;


 The history of [ 459 ] even (plus (u1, u1)) = true ;
 The history of [ 460 ] odd (S (plus (u1, u1))) = true ;TOTAL CASE REWRITING 1: simplify clause
[ 460 ] odd (S (plus (u1, u1))) = true ;

at position true/1/[1] on 	odd (S (plus (u1, u1)))


 The current clause is added to H since the new conjectures are smaller : 

« [ 460 ] odd (S (plus (u1, u1))) = true ;

with the rules 

1) [ 32 ] even (u1) = true => odd (S (u1)) -> true ;
2) [ 33 ] even (u1) = false => odd (S (u1)) -> false ;

resulting

» 1) [ 475 ] even (plus (u1, u1)) = true => true = true ;

using [ 32 ] from R

» 2) [ 479 ] even (plus (u1, u1)) = false => false = true ;

using [ 33 ] from R


TAUTOLOGY: delete
« [ 475 ] even (plus (u1, u1)) = true => true = true ;


 The IH ([ 459 ] even (plus (u1, u1)) = true ; <! u1, u1 !>) will be checked !!! 


Failed to find a cycle to check the iH ([ 459 ] even (plus (u1, u1)) = true ; <! u1, u1 !>), so the conjecture [ 479 ] is put on standby !



Current goals E11 (2):
[ 459 ] even (plus (u1, u1)) = true ;
[ 479 ] even (plus (u1, u1)) = false => false = true ;


 The history of [ 459 ] even (plus (u1, u1)) = true ;
 The history of [ 479 ] even (plus (u1, u1)) = false => false = true ;

<!  !> 
 	 on [ 460 ] odd (S (plus (u1, u1))) = true ;

 The corresponding instance is 
	[ 489 ] odd (S (plus (u1, u1))) = true ;
Current premises H11 (1):
[ 460 ] odd (S (plus (u1, u1))) = true ;


GENERATE 10 on
« [ 459 ] even (plus (u1, u1)) = true ;

from the positions:
	true/1/[1] --> even (plus (u1, u1))
	true/1/[1-1] --> plus (u1, u1)
	
at true/1/[1-1] on 	plus (u1, u1) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u1, S (u2) !>

We obtain :

1) [ 499 ] even (0) = true ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 505 ] even (S (plus (u2, S (u2)))) = true ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


REWRITING 22: simplify by rewriting 
« [ 499 ] even (0) = true ;


- rewriting at the position true/1/[1]:

even (0)
   is simplified by : even (0) -> true   (from [ 28 ] of R)
   with substitution: <!  !> into
true


» [ 520 ] true = true ;

TAUTOLOGY: delete
« [ 520 ] true = true ;


REWRITING 23: simplify by rewriting 
« [ 505 ] even (S (plus (u2, S (u2)))) = true ;


- rewriting at the position true/1/[1-1-1]:

plus (u2, S (u2))
   is simplified by : plus (u1, S (u2)) -> S (plus (u1, u2))   (from [ 400 ] of L)
   with substitution: <! u1, u2 ; u2, u2 !> into
S (plus (u2, u2))


» [ 523 ] even (S (S (plus (u2, u2)))) = true ;


Current goals E12 (2):
[ 479 ] even (plus (u1, u1)) = false => false = true ;
[ 523 ] even (S (S (plus (u2, u2)))) = true ;


 The history of [ 479 ] even (plus (u1, u1)) = false => false = true ;

<!  !> 
 	 on [ 460 ] odd (S (plus (u1, u1))) = true ;

 The corresponding instance is 
	[ 531 ] odd (S (plus (u1, u1))) = true ;

 The history of [ 523 ] even (S (S (plus (u2, u2)))) = true ;

<! u1, S (u2) !> 
 	 on [ 459 ] even (plus (u1, u1)) = true ;

<!  !> 
 	 on [ 505 ] even (S (plus (u2, S (u2)))) = true ;

 The corresponding instance is 
	[ 533 ] even (plus (S (u2), S (u2))) = true ;
Current premises H12 (2):
[ 460 ] odd (S (plus (u1, u1))) = true ;
[ 459 ] even (plus (u1, u1)) = true ;

TOTAL CASE REWRITING 2: simplify clause
[ 523 ] even (S (S (plus (u2, u2)))) = true ;

at position true/1/[1] on 	even (S (S (plus (u2, u2))))


 The current clause is added to H since the new conjectures are smaller : 

« [ 523 ] even (S (S (plus (u2, u2)))) = true ;

with the rules 

1) [ 29 ] odd (u1) = true => even (S (u1)) -> true ;
2) [ 30 ] odd (u1) = false => even (S (u1)) -> false ;

resulting

» 1) [ 539 ] odd (S (plus (u2, u2))) = true => true = true ;

using [ 29 ] from R

» 2) [ 543 ] odd (S (plus (u2, u2))) = false => false = true ;

using [ 30 ] from R


TAUTOLOGY: delete
« [ 539 ] odd (S (plus (u2, u2))) = true => true = true ;


 The IH ([ 460 ] odd (S (plus (u1, u1))) = true ; <! u1, u2 !>) will be checked !!! 


The standby conjectures are: [ 479 ] even (plus (u1, u1)) = false => false = true ;

 The IH_sbc ([ 459 ] even (plus (u1, u1)) = true ; <! u1, u1 !>) is found !

REWRITING 24: simplify by rewriting 
« [ 543 ] odd (S (plus (u2, u2))) = false => false = true ;

- rewriting at the position false/1/[1]:

odd (S (plus (u2, u2)))
   is simplified by : odd (S (plus (u1, u1))) -> true   (from [ 460 ] of C1)
   with substitution: <! u1, u2 !> into
true

» [ 554 ] true = false => false = true ;


 A 2-cycle has been found using the standby conjecture [ 479 ] even (plus (u1, u1)) = false => false = true ;

The IHs ([460 ], <! u1, u2 !>) and ([ 459 ], (<! u1, u1 !>) are checked by the 2-cycle: 

	([ 460 ] odd (S (plus (u1, u1))) = true ; <!  !>)


	([ 459 ] even (plus (u1, u1)) = true ; <! u1, S (u2) !>)
	([ 505 ] even (S (plus (u2, S (u2)))) = true ; <!  !>)
	([ 523 ] even (S (S (plus (u2, u2)))) = true ; <!  !>)




 The 2-cycle unblocked the following operation on [ 479 ]:


REWRITING 21: simplify by rewriting 
« [ 479 ] even (plus (u1, u1)) = false => false = true ;

- rewriting at the position false/1/[1]:

even (plus (u1, u1))
   is simplified by : even (plus (u1, u1)) -> true   (from [ 459 ] of C1)
   with substitution: <! u1, u1 !> into
true

» [ 488 ] true = false => false = true ;

TAUTOLOGY: delete
« [ 554 ] true = false => false = true ;

TAUTOLOGY: delete
« [ 488 ] true = false => false = true ;



The following initial conjectures are inductive consequences of R

[ 459 ] even (plus (u1, u1)) = true ;

[ 460 ] odd (S (plus (u1, u1))) = true ;
Elapsed time: 0.070239 s

--- Global statistics of the main successful operations ---

- tautology               : 12 of 103 tries.
- rewriting               : 24 of 43 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 0 of 75 tries.
- total_case_rewriting    : 2 of 15 tries.
- generate                : 10 of 10 tries.

-----------
  Total clauses: 560

-----------
  Total lemmas: 5

  Max depth    : 1

************************  Proving  *************************
[ 561 ] plus (u1, u2) = plus (u2, u1) ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 304 ] evenm (u1) = evenr (u1) ;
[ 370 ] plus (u1, 0) -> u1 ;
[ 400 ] plus (u1, S (u2)) -> S (plus (u1, u2)) ;
[ 459 ] even (plus (u1, u1)) -> true ;
[ 460 ] odd (S (plus (u1, u1))) -> true ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

Current goals E13 (1):
[ 561 ] plus (u1, u2) = plus (u2, u1) ;


 The history of [ 561 ] plus (u1, u2) = plus (u2, u1) ;
GENERATE 11 on
« [ 561 ] plus (u1, u2) = plus (u2, u1) ;

from the positions:
	true/1/[1] --> plus (u1, u2)
	true/1/[2] --> plus (u2, u1)
	
at true/1/[1] on 	plus (u1, u2) 	 using the test substitutions:

 1) <! u1, 0 ; u2, 0 !>
 2) <! u1, 0 ; u2, S (u3) !>
 3) <! u1, S (u3) ; u2, 0 !>
 4) <! u1, S (u3) ; u2, S (u4) !>

We obtain :

1) [ 585 ] 0 = plus (0, 0) ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
2) [ 591 ] S (u3) = plus (S (u3), 0) ;

using the rule [ 17 ] plus (0, u1) -> u1 ;
3) [ 597 ] S (plus (u3, 0)) = plus (0, S (u3)) ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;
4) [ 603 ] S (plus (u3, S (u4))) = plus (S (u4), S (u3)) ;

using the rule [ 18 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;


SUBSUMPTION: delete
« [ 585 ] 0 = plus (0, 0) ;

Subsumed in L by [ 370 ] plus (u1, 0) -> u1 ;

	with epsilon = <! u1, 0 !>


SUBSUMPTION: delete
« [ 591 ] S (u3) = plus (S (u3), 0) ;

Subsumed in L by [ 370 ] plus (u1, 0) -> u1 ;

	with epsilon = <! u1, S (u3) !>


REWRITING 25: simplify by rewriting 
« [ 597 ] S (plus (u3, 0)) = plus (0, S (u3)) ;


- rewriting at the position true/1/[1-1]:

plus (u3, 0)
   is simplified by : plus (u1, 0) -> u1   (from [ 370 ] of L)
   with substitution: <! u1, u3 !> into
u3


» [ 630 ] S (u3) = plus (0, S (u3)) ;


REWRITING 26: simplify by rewriting 
« [ 603 ] S (plus (u3, S (u4))) = plus (S (u4), S (u3)) ;


- rewriting at the position true/1/[1-1]:

plus (u3, S (u4))
   is simplified by : plus (u1, S (u2)) -> S (plus (u1, u2))   (from [ 400 ] of L)
   with substitution: <! u1, u3 ; u2, u4 !> into
S (plus (u3, u4))


» [ 641 ] S (S (plus (u3, u4))) = plus (S (u4), S (u3)) ;


REWRITING 27: simplify by rewriting 
« [ 630 ] S (u3) = plus (0, S (u3)) ;


- rewriting at the position true/1/[2]:

plus (0, S (u3))
   is simplified by : plus (0, u1) -> u1   (from [ 17 ] of R)
   with substitution: <! u1, S (u3) !> into
S (u3)


» [ 652 ] S (u3) = S (u3) ;

TAUTOLOGY: delete
« [ 652 ] S (u3) = S (u3) ;


REWRITING 28: simplify by rewriting 
« [ 641 ] S (S (plus (u3, u4))) = plus (S (u4), S (u3)) ;


- rewriting at the position true/1/[2]:

plus (S (u4), S (u3))
   is simplified by : plus (S (u1), u2) -> S (plus (u1, u2))   (from [ 18 ] of R)
   with substitution: <! u1, u4 ; u2, S (u3) !> into
S (plus (u4, S (u3)))


» [ 657 ] S (S (plus (u3, u4))) = S (plus (u4, S (u3))) ;

POSITIVE DECOMPOSITION : simplify
« [ 657 ] S (S (plus (u3, u4))) = S (plus (u4, S (u3))) ;

» [ 665 ] S (plus (u3, u4)) = plus (u4, S (u3)) ;


REWRITING 29: simplify by rewriting 
« [ 665 ] S (plus (u3, u4)) = plus (u4, S (u3)) ;


- rewriting at the position true/1/[2]:

plus (u4, S (u3))
   is simplified by : plus (u1, S (u2)) -> S (plus (u1, u2))   (from [ 400 ] of L)
   with substitution: <! u1, u4 ; u2, u3 !> into
S (plus (u4, u3))


» [ 675 ] S (plus (u3, u4)) = S (plus (u4, u3)) ;

POSITIVE DECOMPOSITION : simplify
« [ 675 ] S (plus (u3, u4)) = S (plus (u4, u3)) ;

» [ 683 ] plus (u3, u4) = plus (u4, u3) ;


SUBSUMPTION: delete
« [ 683 ] plus (u3, u4) = plus (u4, u3) ;

Subsumed in C1 by [ 561 ] plus (u1, u2) = plus (u2, u1) ;

	with epsilon = <! u1, u3 ; u2, u4 !>

The IH ([ 561 ] plus (u1, u2) = plus (u2, u1) ; <! u1, u3 ; u2, u4 !>) is checked by the 1-cycle

	([ 561 ] plus (u1, u2) = plus (u2, u1) ; <! u1, S (u3) ; u2, S (u4) !>)
	([ 603 ] S (plus (u3, S (u4))) = plus (S (u4), S (u3)) ; <!  !>)
	([ 641 ] S (S (plus (u3, u4))) = plus (S (u4), S (u3)) ; <!  !>)
	([ 657 ] S (S (plus (u3, u4))) = S (plus (u4, S (u3))) ; <!  !>)
	([ 665 ] S (plus (u3, u4)) = plus (u4, S (u3)) ; <!  !>)
	([ 675 ] S (plus (u3, u4)) = S (plus (u4, u3)) ; <!  !>)



The following initial conjectures are inductive consequences of R

[ 561 ] plus (u1, u2) = plus (u2, u1) ;
Elapsed time: 0.078633 s

--- Global statistics of the main successful operations ---

- tautology               : 13 of 124 tries.
- rewriting               : 29 of 49 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 2 of 89 tries.
- total_case_rewriting    : 2 of 16 tries.
- generate                : 11 of 11 tries.

-----------
  Total clauses: 698

-----------
  Total lemmas: 6

  Max depth    : 1

************************  Proving  *************************
[ 699 ] evenm (plus (u1, u1)) = true ;
[ 700 ] oddm (plus (u1, u1)) = false ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 46 ] evenr (plus (u1, u2)) = true /\ evenr (plus (u2, u3)) = true => evenr (plus (u1, u3)) = true ;
[ 304 ] evenm (u1) = evenr (u1) ;
[ 370 ] plus (u1, 0) -> u1 ;
[ 400 ] plus (u1, S (u2)) -> S (plus (u1, u2)) ;
[ 459 ] even (plus (u1, u1)) -> true ;
[ 460 ] odd (S (plus (u1, u1))) -> true ;
[ 561 ] plus (u1, u2) = plus (u2, u1) ;


using strategy 

fullind mixed with DRaCuLa
************************************************************

REWRITING 30: simplify by rewriting 
« [ 699 ] evenm (plus (u1, u1)) = true ;


- rewriting at the position true/1/[1]:

evenm (plus (u1, u1))
   is simplified by : evenm (u1) -> evenr (u1)   (from [ 304 ] of L)
   with substitution: <! u1, plus (u1, u1) !> into
evenr (plus (u1, u1))


» [ 719 ] evenr (plus (u1, u1)) = true ;


REWRITING 31: simplify by rewriting 
« [ 700 ] oddm (plus (u1, u1)) = false ;


- rewriting at the position true/1/[1-1]:

plus (u1, u1)
   is simplified by : plus (u1, u2) -> plus (u2, u1)   (from [ 561 ] of L)
   with substitution: <! u1, u1 ; u2, u1 !> into
plus (u1, u1)


» [ 731 ] oddm (plus (u1, u1)) = false ;



Uncaught exception: Failure("transitivity problem")


 while proving the following initial conjectures
[ 699 ] evenm (plus (u1, u1)) = true ;
[ 700 ] oddm (plus (u1, u1)) = false ;
Elapsed time: 0.080453 s

--- Global statistics of the main successful operations ---

- tautology               : 13 of 130 tries.
- rewriting               : 31 of 51 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 2 of 95 tries.
- total_case_rewriting    : 2 of 16 tries.
- generate                : 11 of 11 tries.

-----------
  Total clauses: 743

-----------
  Total lemmas: 6

  Max depth    : 1


We failed


